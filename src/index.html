<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gatekeeper Web Demo</title>
    <style>
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(180deg); }
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
        }

        header {
            /* background-color: #333; */
            background-image: url('images/GKBanner3.svg');
            background-repeat: no-repeat;
            background-size: cover;
            color: white;
            padding: 10px;
            text-align: center;
        }

        header h1 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 40px;
            font-weight: normal;
            margin: 15px;
            color: rgb(29, 14, 137);
            text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;
        }

        nav {
            width: 200px;
            background-color: #f0f0f0;
            float: left;
            height: 100vh;
        }

        nav a {
            display: block;
            padding: 15px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #ccc;
        }

        nav a:hover {
            background-color: #ddd;
        }

        nav a.clicked {
            color: rgb(122, 167, 239); /* Change text color to white */
            font-weight: bold;
        }

        main {
            margin-left: 220px;
            padding: 20px;
        }

        main input {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        canvas {
            border: 1px solid #000;
            display: block;
            margin: auto;
        }

        .myAudio {
            width: 300px;
            height: 50px;
        }

        .gkResultWaiting {
            animation: rotate 0.5s linear infinite;
        }

        #audioTable {
            margin-top: 10px;
            border-collapse: collapse;
            width: 100%;
        }

        #audioTable th, #audioTable td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center; /* Center justification */
        }

        #audioTable th {
            background-color: #f2f2f2;
            border-right: none; /* Remove right border for each cell */
            border-left: none; /* Remove left border for each cell */
            font-size: 14px;
        }

        #audioTable td {
            border-right: none; /* Remove right border for each cell */
            border-left: none; /* Remove left border for each cell */
            font-size: 14px;
        }

        #audioTable td p {
            line-height: 1.1; /* line height will be 1.1 times the text size */
        }

        #gkResultImage {
            height: 30;
        }

        #audioVisualization {
            width: 100%;
            height: 200px;
        }

        #settings-panel {
            position: fixed; /* position fixed so it doesn't scroll with the page */
            right: -330px; /* start off the screen */
            top: 103px;
            width: 300px;
            height: 50%;
            background: #fff;
            padding: 15px;
            border: 1px solid #a7a7a7;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            transition: right 0.3s ease-in-out;
        }

        #settings-panel.open {
            right: 0; /* slide in */
        }

        #settings-button {
            position: fixed;
            right: 0px;
            top: 103px;
            height: 40px;
            width: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            padding: 0;
            border: 1px solid #a7a7a7;
            border-radius: 4px;
            border-right: 4px solid white;
            transition: right 0.3s ease-in-out;
        }

        #settings-panel.p {
            padding: 0;
            margin: 0;
        }

        #settings-button.open {
            right: 328px; /* slide in */
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 30px;
            height: 20px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(10px); /* for older chrome based browsers */
            -ms-transform: translateX(10px); /* for older Microsoft browsers */
            transform: translateX(10px); /* for modern browsers. (Previous two lines should be redundent) */
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        #tagInfoText {
            font-size: 60%;
        }

        .helpIcon {
            cursor: pointer;
            width: 20px;
            height: 20px;
            stroke: #2196F3;
        }

        .popup {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            padding: 12px 16px;
            z-index: 1;
            border: 1px solid #908f8f;
            border-radius: 10px; 
        }

        .timer {
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1em; /* 1em is the height of the current font */
            padding: 0;
            margin: 0;
        }

        .enrolStatus {
            display: none;
            color: rgb(42, 42, 250);
            justify-content: center;
            align-items: center;
        }

        .container {
            display: flex;
            /* justify-content: space-between; */
            align-items: center;
            padding: 0px;
        }

        .enrolrow {
            background-color: #e5f2fb;
        }

        .verifyrow {
            background-color: #ffffff;
        }

        .apiKey {
            display: flex;
            align-items: flex-start;
            padding-top: 20px;
            padding-bottom: 20px;
        }

        .apiKey label {
            margin-right: 5px;
        }

        .hidden {
            display: none;
        }

        #popup-container {
            position: fixed; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #popup-message {
            position: relative;
            /* Centering text adjustments */
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            /* Add box shadow */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1), 0 6px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            /* Add dimensions if not dynamically sized */
            width: 300px; /* Example width */
            height: 100px; /* Example height */
        }

        #popup-close {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 20px;
        }

        #apiKey {
            resize: none;
        }

    </style>
</head>
<body>

    <header>
        <h1>Gatekeeper Web Demo</h1>
    </header>

    <nav>
        <a href="#" onclick="changeFunction(this)" class='clicked'>Verify</a>
        <a href="#" onclick="changeFunction(this)">Enrol</a>
        <!-- <a href="#" onclick="changeColor(this)">Fraud Check</a> -->
    </nav>

    <main>

        <h2 id="functionHeader">Verify</h2>
        <!-- <p><label for="inputField">Speaker ID: </label><input type="text" id="speakerID" placeholder="Speaker ID" value="IanMcG"></p> -->

        <div class="container">
            <div id="SpeakerEntry">
                <label for="inputField">Speaker ID: </label><input type="text" id="speakerID" placeholder="Speaker ID">
            </div>
            <div id="ConsentCapture" class="hidden">
                <input type="checkbox" id="checkbox">
                <label for="checkbox">I agree to my recording being used to create a voiceprint</label>
            </div>
        </div>

        <!-- <p><label for="inputField">Speaker ID: </label><input type="text" id="speakerID" placeholder="Speaker ID"></p> -->
        <p id="someText">Click the Microphone to start recording.</p>

        <!-- Canvas element -->
        <!-- <canvas id="audioVisualization" width="400" height="200"></canvas> -->
        <canvas id="audioVisualization"></canvas>

        <div class="timer">
            <p id="timer">&nbsp;</p>
        </div>

        <div class="enrolStatus" id="enrolBlock">

            <p id="enrolStatus">To enrol, just speak for about 20s. You can say whatever you want. For eample, repeat your full name, full address, date of birth, telephone number... anything!</p>
        </div> 

        <table id="audioTable">
            <thead>
                <tr>
                    <th>Date and Time</th>
                    <th>SpeakerID</th>
                    <th>Enrol/Verify</th>
                    <th>Recording</th>
                    <th>VB Result</th>
                    <th>VB Score</th>
                    <th>Risk Score</th>
                    <th></th>
                    <th><img src="images/delete(black).svg" width="20px" onclick="deleteAllRows()" alt="Delete all rows" title="Delete All"></th>
                </tr>
            </thead>
            <tbody id="audioTableBody"></tbody>
        </table>

        <!-- the settings panel -->
        <div id="settings-panel">
            <p>Settings</p>
            <!-- Add your settings controls here -->
            <label class="switch">
                <input type="checkbox" id="toggleTagId">
                <span class="slider round"></span>
            </label>
            <label for="tagId">Tag ID:</label>
            <input type="text" id="tagId" name="tagId" size="10" placeholder="TI_10">
            <svg class="helpIcon" id="tagIdHelpIcon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g>
                <circle cx="8" cy="8" r="6.5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></circle>
                <circle cx="8" cy="11" r="0.5"></circle>
                <path d="M6.5 4.99999C7.3 4.36999 8.56 4.36999 9.1998 4.8C10.0561 5.37086 10.0561 6.62914 9.1998 7.2L7.9998 8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
                </g>
            </svg>
            <div id="tagHelpPopup" class="popup">
                <p>If a TagID is provided then this will be used for verifications and for enrolment.</p>
                <p>If TagID isn't used then the first voiceprint for that speaker will be used for verifications, and TagID of "TI_10" will be used for enrolments.</p>
            </div>

            <div class="apiKey">
                <label for="apiKey">API Key:</label>
                <textarea id="apiKey" placeholder="Enter APIKey here" rows="8" cols="20"></textarea>
                <!-- <input type="password" id="apiKey" name="apiKey" size="25" placeholder="API Key"> -->
                <!-- <textarea id="apiKey" name="apiKey" rows="4" cols="32"></textarea> -->
                <img src="images/hide.svg" id="toggleButton" alt="hide" height="15px" onclick="toggleAPIView()">

            </div>

        </div>
        <!-- Placing the settings-button after the settings-panel means that it's white right hand border
        overwrites the border of the settings-panle where they overlap -->
        <div id="settings-button">
            <img src="images/settings.svg" width="30px" onclick="toggleSettingsPanel()" alt="Settings" title="Settings">
        </div>

        <!-- Popup Container -->
        <div id="popup-container" style="display:none;">
            <!-- Popup Message -->
            <div id="popup-message">
                <span id="popup-text">This is an alert message!</span>
            
            <!-- Close Button ("X") -->
            <span id="popup-close" onclick="closePopup()">X</span>
            </div>
        </div>
  
        <script>
    
            // Code to mask the API Key
            let isMasked = false;
            let actualContent = '';
            const toggleButton = document.getElementById('toggleButton');

            const textarea = document.getElementById('apiKey');

            textarea.addEventListener('input', function() {
                if (isMasked) {
                    // Append the new text to actualContent and replace the new text with asterisks
                    const newText = textarea.value.replace(/\*/g, '');
                    actualContent += newText;
                    textarea.value = textarea.value.replace(/[^*]/g, '*');
                } else {
                    actualContent = textarea.value;
                }
                // Save the apiKey to the cookie using the actualContent variable (which is not masked)
                document.cookie = "apiKey=" + actualContent + "; expires=Fri, 31 Dec 2100 12:00:00 UTC; path=/;";

            });

            function toggleAPIView() {
                if (!isMasked) {
                    // Store the actual content and replace the visible content with asterisks
                    actualContent = textarea.value;
                    textarea.value = '*'.repeat(actualContent.length);
                    isMasked = true;
                    toggleButton.src = 'images/show.svg';
                } else {
                    // Restore the actual content
                    textarea.value = actualContent;
                    isMasked = false;
                    toggleButton.src = 'images/hide.svg';
                }
            }

            // const popupOverlay = document.getElementById('popup-overlay');
            const popupMessage = document.getElementById('popup-message');
            const popupText = document.getElementById('popup-text');
            const popupClose = document.getElementById('popup-close');

            function showPopup() {
                document.getElementById('popup-container').style.display = 'flex';
            }

            function closePopup() {
                document.getElementById('popup-container').style.display = 'none';
            }

            function showAlert(message) {
                popupText.innerHTML = message;
                showPopup();
            }

            function getFunctionMode() {
                // Check which of the nav links has the 'clicked' class
                const navLinks = document.querySelectorAll('nav a');
                navLinks.forEach(navLink => {
                    if (navLink.classList.contains('clicked')) {
                        functionMode = navLink.innerHTML;
                    }
                });
                return functionMode;
            }
        
            // Get the settings panel
            const settingsPanel = document.getElementById('settings-panel');
            // Get the settings button
            const settingsButton = document.getElementById('settings-button');

            // Add an event listener to the toggleTagId checkbox
            document.getElementById('toggleTagId').addEventListener('change', function() {
                document.getElementById('tagId').disabled = !this.checked;
            });

            // Add an event listener to the help icon
            document.getElementById('tagIdHelpIcon').addEventListener('click', function(event) {
                var popup = document.getElementById('tagHelpPopup');
                popup.style.display = popup.style.display === 'block' ? 'none' : 'block';
                console.log(popup.style.display);
            });

            // Function to open the settings panel
            function toggleSettingsPanel() {
                if (settingsPanel.classList.contains('open')) {
                    // Close the panel
                    settingsButton.classList.remove('open');
                    settingsPanel.classList.remove('open');
                } else {
                    // Open the panel
                    settingsButton.classList.add('open');
                    settingsPanel.classList.add('open');
                }
            }

            // Get the canvas and its context
            const visualizationCanvas = document.getElementById('audioVisualization');
            const visualizationContext = visualizationCanvas.getContext('2d');

            visualizationCanvas.width = visualizationCanvas.offsetWidth;
            visualizationCanvas.height = visualizationCanvas.offsetHeight;

            // MediaRecorder variables
            // let mediaRecorder;
            let scriptNode;
            let isRecording = false;
            let audioBuffer = []; // stores the audio recorded by the scriptNode
            let audioContext;
            let analyser;
            let dataArray; // used by analyser
            let gkResultCounter = 0;
            let animationFrameId;
            let isPulsing = false;
            let pulseSize = 0;
            let audioSource; // This is the audio source used by the scriptNode and analyser
            const numChannels = 1;
            const sampleRate = 48000;
            let timer;

            // Load Gatekeeper logo SVG file
            const gatekeeperImg = new Image();
            gatekeeperImg.src = 'images/gatekeeper-nuance-colors.svg';
            gatekeeperImg.onload = function () {
                // Draw the Gatekeeper logo onto the canvas
                console.log("Gatekeeper logo loaded");
                
                // drawGatekeeperLogo();
            };

            // Load the microphone SVG file
            const microphoneImg = new Image();
            microphoneImg.src = 'images/microphone.svg';
            microphoneImg.onload = function () {
                // Draw the microphone onto the canvas
                resetVisualisation();
                //drawMicrophone('#58f5a2');
            };
            
            
            function drawMicrophone(color) {
                // visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height); // this was hiding the audio wave
                visualizationContext.fillStyle = color;
                visualizationContext.beginPath();
                visualizationContext.arc(visualizationCanvas.width / 2, visualizationCanvas.height / 2, 50, 0, 2 * Math.PI);
                visualizationContext.fill();

                // Calculate the position to center the image
                const x = (visualizationCanvas.width - 100) / 2;
                const y = (visualizationCanvas.height - 100) / 2;

                // Draw the SVG onto the canvas at the center with dimensions 50x50
                visualizationContext.strokeStyle = '#000';
                visualizationContext.drawImage(microphoneImg, x, y, 100, 100);
            }

            function drawGatekeeperLogo() {
                // visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height); // this was hiding the audio wave
                visualizationContext.fillStyle = '#fff'; 
                visualizationContext.beginPath();
                visualizationContext.arc(visualizationCanvas.width / 2, visualizationCanvas.height / 2, 70, 0, 2 * Math.PI);
                visualizationContext.fill();

                // draw the gatekeeperImg in the centre of the canvas
                // Calculate the scale factor
                const gkHeight = 100;
                const scaleFactor = gkHeight / gatekeeperImg.height;

                // Calculate the new width and height
                // const newWidth = gatekeeperImg.width * scaleFactor;
                // const newHeight = 100; // the height is set to 100px

                // Allow for logo to pulse
                const newWidth = (gatekeeperImg.width * scaleFactor) + pulseSize;
                const newHeight = gkHeight + pulseSize; // the height is set to 100px


                // Calculate the position to center the image
                const x = (visualizationCanvas.width - newWidth) / 2;
                const y = (visualizationCanvas.height - newHeight) / 2;

                visualizationContext.strokeStyle = '#000';
                visualizationContext.drawImage(gatekeeperImg, x, y, newWidth, newHeight);
            }

            function pulseLogo() {
                if (!isPulsing){
                    return;
                }

                pulseSize = Math.sin(Date.now() / 200) * 25; // adjust numbers for different effects

                drawGatekeeperLogo();

                animationFrameId = requestAnimationFrame(pulseLogo);
            }

            // Add an onclick event handler to display coordinates
            visualizationCanvas.onclick = function (event) {
                const rect = visualizationCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const text = document.getElementById('someText');

                // alert(`Clicked at coordinates: (${mouseX}, ${mouseY})`);

                const centreX = visualizationCanvas.width / 2;
                const centreY = visualizationCanvas.height / 2;

                const minx = centreX - 50;
                const maxx = centreX + 50;
                const miny = centreY - 50;
                const maxy = centreY + 50;

                if(mouseX > minx && mouseX < maxx && mouseY > miny && mouseY < maxy){
                    // Check that we have an API Key set otherwise the middleware will not be called
                    if (document.getElementById('apiKey').value == '') {
                        showAlert('Please supply an API Key');
                        return;
                    }
                    // Ensure that a speakerId has been entered
                    if (document.getElementById('speakerID').value == '') {
                        showAlert('Please enter a Speaker ID');
                        return;
                    }
                    // If function is Enrol then check that the consent checkbox is checked
                    if (getFunctionMode() === 'Enrol') {
                        if (!document.getElementById('checkbox').checked) {
                            showAlert('Please check the consent checkbox');
                            return;
                        }
                    }
                    // Clicked on microphone so toggle recording
                    toggleRecording();
                }


            };

            // Add mouseover and mouseout event handlers to change cursor style
            visualizationCanvas.addEventListener('mousemove', function (event) {
                const rect = visualizationCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const text = document.getElementById('someText');

                const centreX = visualizationCanvas.width / 2;
                const centreY = visualizationCanvas.height / 2;

                const minx = centreX - 50;
                const maxx = centreX + 50;
                const miny = centreY - 50;
                const maxy = centreY + 50;

                if(mouseX > minx && mouseX < maxx && mouseY > miny && mouseY < maxy){
                    inzone = "yes";
                    visualizationCanvas.style.cursor = 'pointer';
                }
                else{
                    inzone = "no";
                    visualizationCanvas.style.cursor = 'default';
                }
                // text.innerHTML = `Mouse at coordinates: (${mouseX}, ${mouseY}) ${inzone}`;

            });

            visualizationCanvas.addEventListener('mouseout', function () {
                visualizationCanvas.style.cursor = 'default';
            });
            
            // Initialise mediaRecorder

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                // Constraints for the getUserMedia function
                const constraints = {
                    audio: {
                        channels: numChannels, // Mono
                    }
                };

                // Request access to the user's microphone
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(handleSuccess)
                    .catch(handleError);
            } else {
                console.error('Web Audio API is not supported in this browser.');
            }

            // Handle success by setting up MediaRecorder on the stream
            function handleSuccess(stream) {
                // Create an AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create a media stream source from the microphone
                audioSource = audioContext.createMediaStreamSource(stream);

                // Create a script processor node to process the audio
                scriptNode = audioContext.createScriptProcessor(4096, 1, 1); // bufferSize, inputChannels, outputChannels

                // Connect the source to the script node
                audioSource.connect(scriptNode);

                // Setup the visualisation using an AnalyserNode
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;  // Reduce the buffer size for potential performance improvement
                analyser.smoothingTimeConstant = 0.8;
                dataArray = new Uint8Array(analyser.fftSize);

                audioSource.connect(analyser);
            }

            // Handle error by logging to the console
            function handleError(error) {
                console.error('Error accessing microphone:', error);
            }

            // Update the web page to add a new entry to the audio table
            function updateAudioTable(audioUrl, spkrId, operation){

                const dateTime = new Date().toLocaleString();

                // Create a new row in the table
                const tableBody = document.getElementById('audioTableBody');
                const newRow = tableBody.insertRow(0);
                const cell1 = newRow.insertCell(0);
                const cell2 = newRow.insertCell(1);
                const cell3 = newRow.insertCell(2);
                const cell4 = newRow.insertCell(3);
                const cell5 = newRow.insertCell(4);
                const cell6 = newRow.insertCell(5);
                const cell7 = newRow.insertCell(6);
                const cell8 = newRow.insertCell(7);
                const cell9 = newRow.insertCell(8);

                // Set the row to be enrolrow class id operation is Enrol, otherwise set to verifyrow
                if (operation == 'Enrol') {
                    newRow.className = 'enrolrow';
                } else {
                    newRow.className = 'verifyrow';
                }

                // Set values in the cells
                cell1.textContent = dateTime;

                cell2.textContent = spkrId;
                cell3.textContent = operation;


                cell4.innerHTML = `<audio class="myAudio" controls controlsList="nodownload"><source src="${audioUrl}" type="audio/wav"></audio>`;
                var imageHolder = document.createElement('img');
                imageHolder.className = 'gkResultWaiting';
                imageHolder.id = 'gkResultImage' + gkResultCounter;
                imageHolder.src = 'images/hourglass.svg';
                imageHolder.width = 20;
                var resultText = document.createElement('p');
                resultText.id = 'gkResultText' + gkResultCounter;
                cell5.innerHTML = imageHolder.outerHTML;
                cell6.innerHTML = '...';
                cell7.innerHTML = '...';
                cell8.innerHTML = `<a href="${audioUrl}" download="recording_${dateTime}.wav"><img width="20px" src="images/download_icon.svg" title="Download Audio"></a>`;
                cell9.innerHTML = `<img width="20px" src="images/delete.svg" onclick="deleteRow(this)" title="Delete">`;
            
            }

            // Toggle recording function
            function toggleRecording() {
                const infoText = document.getElementById('someText');
                const timerText = document.getElementById('timer');

                if (!isRecording) {
                    // if we are processing with the middleware then don't start a new recording
                    if (processingState) {
                        return;
                    }
                    startRecording();
                    infoText.innerHTML = `Click the microphone to stop recording...`;
                    // start the timer
                    timerText.innerHTML = `0s`;
                    timer = setInterval(function() {
                        // Update the timer text by 0.1s and ensure the value is rounded to 1 decimal place
                        timerText.innerHTML = (parseFloat(timerText.innerHTML) + 0.1).toFixed(1) + 's';
                                              
                    }, 100);

                } else {
                    stopRecording();
                    infoText.innerHTML = `Click the Microphone to start recording...`;
                    // Now stop the timer
                    clearInterval(timer);
                    timerText.innerHTML = 'Last recording: ' + timerText.innerHTML;
                }
            }

            // Start recording function
            function startRecording() {
                isRecording = true;
                // Connect the script node to the destination (speakers)
                scriptNode.connect(audioContext.destination);
                // Callback function to process audio data
                scriptNode.onaudioprocess = function (audioProcessingEvent) {
                    const inputBuffer = audioProcessingEvent.inputBuffer;
                    // Add the audio data to the buffer
                    audioBuffer.push(new Float32Array(inputBuffer.getChannelData(0)));
                };
                drawVisualization();
            }

            // Stop recording function
            function stopRecording() {         
                isRecording = false;
                // Disconnect the scriptNode
                scriptNode.disconnect(audioContext.destination);

                // Stop the animation frame
                cancelAnimationFrame(animationFrameId);

                resetVisualisation();
                
                // Convert the audio buffer to a WAV blob
                const wavBlob = encodeWAV(audioBuffer);
                const audioUrl = URL.createObjectURL(wavBlob);

                // reset audioBuffer
                audioBuffer = [];

                // Update the audio table on the web page
                if (getFunctionMode() === 'Verify') {
                    updateAudioTable(audioUrl, document.getElementById('speakerID').value, 'Verify');
                } else {
                    updateAudioTable(audioUrl, document.getElementById('speakerID').value, 'Enrol');
                }

                // Now do the verification or enrolment as required
                // Replace the microphone image in the canvas with the Gatekeeper image
                drawGatekeeperLogo();

                // Check if we are in Verify or Enrol function
                const mode = getFunctionMode();
                if (mode === 'Verify') {
                    if (verifyWithMiddleware(wavBlob, gkResultCounter++) == 'ERROR') {
                        console.log("Failed to connect...");
                    }
                } else {
                    if (enrolWithMiddleware(wavBlob, gkResultCounter++) == 'ERROR') {
                        console.log("Failed to connect...");
                    }
                    
                }

            }

            function clearCanvas() {
                // visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
                visualizationContext.fillStyle = '#031748';
                visualizationContext.fillRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
            }

            function resetVisualisation() {
                clearCanvas();
                // visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
                // Draw a horizontal line through the middle of the canvas
                visualizationContext.strokeStyle = '#1AE6C1';
                visualizationContext.lineWidth = 2;
                visualizationContext.beginPath();
                visualizationContext.moveTo(0, visualizationCanvas.height / 2);
                visualizationContext.lineTo(visualizationCanvas.width, visualizationCanvas.height / 2);
                visualizationContext.stroke();

                drawMicrophone('#58f5a2'); // Change circle color back to green

            }

            function visualizeAudio() {
                analyser.getByteTimeDomainData(dataArray);

                // visualizationContext.clearRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
                clearCanvas();
                visualizationContext.beginPath();

                const bufferLength = analyser.fftSize;
                const sliceWidth = visualizationCanvas.width / bufferLength;

                visualizationContext.strokeStyle = '#1AE6C1';
                visualizationContext.lineWidth = 2;
                for (let i = 0; i < bufferLength; i++) {
                    const x = i * sliceWidth;
                    const y = (dataArray[i] / 128.0) * (visualizationCanvas.height / 2);
                    if (i === 0) {
                        visualizationContext.moveTo(x, y);
                    } else {
                        visualizationContext.lineTo(x, y);
                    }
                }

                visualizationContext.stroke();
            }

            function drawVisualization() {
                visualizeAudio();

                // Add the microphone to sit on top
                drawMicrophone('#f56558');

                animationFrameId = requestAnimationFrame(drawVisualization);
            }

            // Delete row function
            function deleteRow(button) {
                const row = button.parentNode.parentNode;
                row.parentNode.removeChild(row);
            }

            // Delete all rows in the audioTable
            function deleteAllRows() {
                if (confirm('Are you sure you want to delete all rows?')) {
                    const tableBody = document.getElementById('audioTableBody');
                    
                    while (tableBody.firstChild) {
                        tableBody.removeChild(tableBody.firstChild);
                    }
                }
            }

            // Change the operation of the web page based on the nav link chosen
            let oldAudioTableState;
            function changeFunction(link) {
                // Remove 'clicked' class from all navigation links
                const navLinks = document.querySelectorAll('nav a');
                navLinks.forEach(navLink => navLink.classList.remove('clicked'));

                // Add 'clicked' class to the clicked navigation link
                link.classList.add('clicked');
                // Change heading text
                document.getElementById('functionHeader').innerHTML = link.innerHTML;

                if (link.innerHTML == 'Enrol') {
                    // If the user has clicked the Enrol link hide the table
                    // oldAudioTableState = document.getElementById('audioTable').style.display;
                    // document.getElementById('audioTable').style.display = 'none';
                    // Show the enrolStatus block
                    document.getElementById('enrolBlock').style.display = 'flex';
                    // change sometext to prompt for enrolment
                    document.getElementById('someText').innerHTML = 'Click the Microphone to start enrolment...';
                    // Make the consent capture checkbox visible
                    document.getElementById('ConsentCapture').classList.remove('hidden');
                } else {
                    // Revert the audio table and hide the enrolStatus block
                    // document.getElementById('audioTable').style.display = oldAudioTableState;
                    document.getElementById('enrolBlock').style.display = 'none';
                    document.getElementById('someText').innerHTML = 'Click the Microphone to start verification...';
                    // Hide the consent capture checkbox
                    document.getElementById('ConsentCapture').classList.add('hidden');
                }
            }

            // prcessingState is used to indicate if we have a request waiting to the Middleware
            // No new recordings should be started if processingState is true
            let processingState = false;

            // VerifyWithMiddleware sends the audio blob to the middleware with the speakerID, 
            // and optional tag, contained in the URL. The middleware returns a JSON object
            // containing the result and reason for the result, and if available the biometric 
            // and risk scores.
            function verifyWithMiddleware(blob, resultCounter){
                var request = new XMLHttpRequest();
                const speakerID = document.getElementById('speakerID').value;
                // request.open("POST", "http://localhost:8080/verify/"+speakerID+"/TI");

                isPulsing = true;
                pulseLogo();
                processingState = true;

                request.open("POST", "https://gkmware.azurewebsites.net/api/Verify/"+speakerID);
                // Add the an authorizartion header to the request of the for Bearer <API Key>
                request.setRequestHeader("Authorization", "Bearer " + document.getElementById('apiKey').value);
                
                request.send(blob);
                var response = '';
                request.onload = function() {
                    let imageHolder = document.getElementById('gkResultImage' + resultCounter);
                    // Stop the animation by changing class of the image from gkResultWaiting to gkResultImage
                    imageHolder.className = 'gkResultImage';
                    processingState = false;
                    if (request.status == 200) {
                        console.log("Middleware returned 200");
                        console.log(request.response);

                        // Get the top table row
                        const tableRow = document.getElementById('audioTableBody').rows[0];

                        var jsonResponse = JSON.parse(request.response);
                        console.log(jsonResponse);
                        response = jsonResponse.result;
                        if (response == 'DECISION_AUTHENTIC') {
                            imageHolder.src = 'images/gatekeeper_open_green.svg';
                        } else if (response == 'DECISION_NO_MATCH') {
                            imageHolder.src = 'images/gatekeeper_red.svg';
                        } else if (response == 'ERROR') {
                            imageHolder.src = 'images/gatekeeper_error.svg';
                        } else {
                            imageHolder.src = 'images/gatekeeper_grey.svg';
                        }
                        imageHolder.width = 30;
                        imageHolder.title = jsonResponse.reason;
                        tableRow.cells[5].innerHTML = jsonResponse.biometricScore;
                        tableRow.cells[6].innerHTML = jsonResponse.riskScore;

                    } else {
                        console.log("Middleware returned " + request.status);
                        console.log(request.response);
                        response = request.response;
                    }
                    // Reset the canvas to show the microphone
                    isPulsing = false;
                    resetVisualisation();
                }

                request.onerror = function() {
                    console.error("An error occurred while making the request to Middleware.");
                    let imageHolder = document.getElementById('gkResultImage' + resultCounter);
                    // Stop the animation by changing class of the image from gkResultWaiting to gkResultImage
                    imageHolder.className = 'gkResultImage';

                    // Get the top table row
                    const tableRow = document.getElementById('audioTableBody').rows[0];

                    processingState = false;
                    imageHolder.src = 'images/gatekeeper_error.svg';
                    imageHolder.width = 30;
                    imageHolder.title = "Failed to connect to middleware";
                    tableRow.cells[3].innerHTML = '-';
                    tableRow.cells[4].innerHTML = '-';

                    // Reset the canvas to show the microphone
                    isPulsing = false;
                    resetVisualisation();
                };
            }


            // enrolWithMiddleware sends the audio blob to the middleware with the speakerID and optional tag
            // contained in the URL. The middleware returns a JSON object containing the result and reason for the result.
            function enrolWithMiddleware(blob, resultCounter){

                var request = new XMLHttpRequest();

                const speakerID = document.getElementById('speakerID').value;
                var tagID = document.getElementById('tagId').value;
                if (tagID == '' || tagID == null) {
                    tagID = 'TI_10';
                }

                // change the enrolStatus text to show that we are processing
                const enrolStatus = document.getElementById('enrolStatus');
                enrolStatus.innerHTML = "Enrolling speaker " + speakerID + " with tag " + tagID + "...";

                isPulsing = true;
                pulseLogo();
                processingState = true;

                request.open("POST", "https://gkmware.azurewebsites.net/api/Enrol/"+speakerID+"/"+tagID);
                // Add the an authorizartion header to the request of the for Bearer <API Key>
                request.setRequestHeader("Authorization", "Bearer " + document.getElementById('apiKey').value);
                request.send(blob);
                var response = '';
                request.onload = function() {
                    let imageHolder = document.getElementById('gkResultImage' + resultCounter);
                    // Stop the animation by changing class of the image from gkResultWaiting to gkResultImage
                    imageHolder.className = 'gkResultImage';
                    processingState = false;
                    if (request.status == 200) {
                        console.log("Middleware returned 200");
                        console.log(request.response);
                        response = request.response;

                        // Get the top table row
                        const tableRow = document.getElementById('audioTableBody').rows[0];

                        var jsonResponse = JSON.parse(request.response);
                        console.log(jsonResponse);
                        response = jsonResponse.result;
                        if (response == 'OK') {
                            imageHolder.src = 'images/enrolSuccess.svg';
                        } else if (response == 'NOT_TRAINED') {
                            imageHolder.src = 'images/enrolPartial.svg';
                        } else if (response == 'ERROR') {
                            imageHolder.src = 'images/enrolFail.svg';
                        } else {
                            imageHolder.src = 'images/enrolFail.svg';
                        }
                        imageHolder.width = 30;
                        imageHolder.title = jsonResponse.reason;
                        tableRow.cells[5].innerHTML = "N/A";
                        tableRow.cells[6].innerHTML = "N/A";

                        enrolStatus.innerHTML = jsonResponse.result + " " + jsonResponse.reason;

                    } else {
                        console.log("Middleware returned " + request.status);
                        console.log(request.response);
                        response = request.response;
                    }

                    // Reset the canvas to show the microphone
                    isPulsing = false;
                    resetVisualisation();
                }

                request.onerror = function() {
                    console.error("An error occurred while making the request to Middleware.");
                    enrolStatus.innerHTML = "Failed to connect to middleware";
                    // Reset the canvas to show the microphone
                    isPulsing = false;
                    processingState = false;
                    resetVisualisation();
                };

            }

            // Turn the 32 bit float RAW data to a wav file
            function encodeWAV(audioData) {

                // The audio data has been captured as an array of Float32Array objects
                // Get the total length of the audio data
                var totalSamples = 0;
                for (var i = 0; i < audioData.length; i++) {
                    totalSamples += audioData[i].length;
                }

                // Create a single Float32Array object, called samples, to hold the audio data
                var samples = new Float32Array(totalSamples);
                var sampleIndex = 0;
                for (var i = 0; i < audioData.length; i++) {
                    for (var j = 0; j < audioData[i].length; j++) {
                        samples[sampleIndex] = audioData[i][j];
                        sampleIndex++;
                    }
                }

                // add wav header and return the resulting wav blob
                wavBlob = addWavHeader(samples, sampleRate, numChannels);
                return(wavBlob);
            }

            function addWavHeader(float32Array, sampleRate, numChannels) {
                // Calculate the total length of the audio data in bytes
                const dataSize = float32Array.length * Float32Array.BYTES_PER_ELEMENT;

                // Create a WAV header
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);

                // Set the RIFF chunk
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataSize, true); // Total file size - 8

                writeString(view, 8, 'WAVE');

                // Set the fmt subchunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // Subchunk1Size
                view.setUint16(20, 3, true); // AudioFormat (3 for IEEE Float)
                view.setUint16(22, numChannels, true); // NumChannels
                view.setUint32(24, sampleRate, true); // SampleRate
                view.setUint32(28, sampleRate * numChannels * Float32Array.BYTES_PER_ELEMENT, true); // ByteRate
                view.setUint16(32, numChannels * Float32Array.BYTES_PER_ELEMENT, true); // BlockAlign
                view.setUint16(34, 32, true); // BitsPerSample (32 for Float)

                // Set the data subchunk
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true); // Subchunk2Size

                // Copy the audio data after the WAV header
                const audioData = new Float32Array(buffer, 44);
                audioData.set(float32Array);

                // Create a Blob from the ArrayBuffer
                const blob = new Blob([buffer], { type: 'audio/wav' });

                return blob;
            }

            function writeString(view, offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }

            window.onresize = function() {
                // Update the canvas width and height
                visualizationCanvas.width = visualizationCanvas.offsetWidth;
                visualizationCanvas.height = visualizationCanvas.offsetHeight;

                // If we are recoring or interacting with the middleware then the canvas will be redrawn automatically
                // otherwise redraw it now
                if (!isRecording && !isPulsing) {
                    resetVisualisation();
                }

            };

            function getCookie(name) {
                let nameEQ = name + "=";
                // console.log("document.cookie = " + document.cookie);
                let ca = document.cookie.split(';');
                for(var i=0;i < ca.length;i++) {
                    let c = ca[i];
                    while (c.charAt(0)==' ') c = c.substring(1,c.length);
                    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
                }
                return null;
            }

            window.onload = function() {
                // Update the canvas width and height
                // Set oldAudioTableState to the current display state of the audioTable
                oldAudioTableState = document.getElementById('audioTable').style.display;

                // read the cookie to get the apiKey then set the value of the apiKey input
                document.getElementById('apiKey').value = getCookie('apiKey');

                // Ensure that the apiKey is masked as the initial state
                if (!isMasked) {
                    toggleAPIView();
                }
            };
        </script>
    </main>

</body>
</html>
